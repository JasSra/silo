using Silo.Core.Pipeline;
using Silo.Api.Services;

namespace Silo.Api.Services.Pipeline;

public class MalwareScanningStep : PipelineStepBase
{
    private readonly IClamAvService _clamAvService;
    private readonly IMinioStorageService _storageService;
    private readonly ClamAvConfiguration _config;
    private readonly IWebHostEnvironment _environment;

    public MalwareScanningStep(
        ILogger<MalwareScanningStep> logger,
        IClamAvService clamAvService,
        IMinioStorageService storageService,
        ClamAvConfiguration config,
        IWebHostEnvironment environment) : base(logger)
    {
        _clamAvService = clamAvService;
        _storageService = storageService;
        _config = config;
        _environment = environment;
    }

    public override string Name => "MalwareScanning";
    public override int Order => 100; // Early in pipeline
    public override IReadOnlyList<string> Dependencies => Array.Empty<string>();

    public override async Task<bool> CanExecuteAsync(PipelineContext context, CancellationToken cancellationToken = default)
    {
        var baseCanExecute = await base.CanExecuteAsync(context, cancellationToken);
        if (!baseCanExecute) return false;
        
        // In development, allow execution even if ClamAV is not available
        if (_environment.IsDevelopment())
        {
            return true;
        }
        
        // Check if ClamAV service is available
        return await _clamAvService.IsAvailableAsync(cancellationToken);
    }

    protected override async Task<PipelineStepResult> ExecuteInternalAsync(PipelineContext context, CancellationToken cancellationToken)
    {
        var fileName = context.FileMetadata.FileName;
        _logger.LogInformation("Starting malware scan for file: {FileName}", fileName);

        try
        {
            // In development, if ClamAV is not available, skip scanning
            if (_environment.IsDevelopment() && !await _clamAvService.IsAvailableAsync(cancellationToken))
            {
                _logger.LogWarning("ClamAV not available in development environment, skipping malware scan for {FileName}", fileName);
                
                var devMetadata = new Dictionary<string, object>
                {
                    ["ScanTimestamp"] = DateTime.UtcNow,
                    ["ScanSkipped"] = true,
                    ["Reason"] = "ClamAV not available in development",
                    ["IsClean"] = true // Assume clean in development
                };

                context.SetStepResult(Name, devMetadata);
                return PipelineStepResult.Succeeded();
            }

            // Create a memory copy of the stream for scanning (preserving original)
            var originalPosition = context.FileStream.Position;
            context.FileStream.Position = 0;
            
            using var scanStream = new MemoryStream();
            await context.FileStream.CopyToAsync(scanStream, cancellationToken);
            
            // Reset original stream position
            context.FileStream.Position = originalPosition;
            
            // Perform the scan
            var scanResult = await _clamAvService.ScanFileAsync(scanStream, fileName, cancellationToken);
            
            var metadata = new Dictionary<string, object>
            {
                ["ScanTimestamp"] = DateTime.UtcNow,
                ["ScanResult"] = scanResult,
                ["IsClean"] = scanResult.IsClean
            };
            
            if (!scanResult.IsClean)
            {
                _logger.LogWarning("Malware detected in file {FileName}: {ThreatName}", fileName, scanResult.ThreatName);
                
                // Handle infected file
                await HandleInfectedFileAsync(context, scanResult, cancellationToken);
                
                metadata["QuarantineAction"] = "File quarantined due to malware detection";
                
                return PipelineStepResult.Failed(
                    $"Malware detected: {scanResult.ThreatName}",
                    metadata);
            }
            
            _logger.LogInformation("File {FileName} passed malware scan", fileName);
            metadata["ScanDetails"] = scanResult.ScanDetails;
            
            return PipelineStepResult.Succeeded(metadata);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error during malware scan for file {FileName}", fileName);
            return PipelineStepResult.Failed($"Malware scan error: {ex.Message}");
        }
    }
    
    private async Task HandleInfectedFileAsync(PipelineContext context, ScanResult scanResult, CancellationToken cancellationToken)
    {
        if (!_config.QuarantineInfectedFiles)
        {
            _logger.LogInformation("Quarantine is disabled, not moving infected file");
            return;
        }
        
        try
        {
            var fileName = context.FileMetadata.FileName;
            var quarantinePath = $"quarantine/{DateTime.UtcNow:yyyy/MM/dd}/{Guid.NewGuid()}_{fileName}";
            
            _logger.LogInformation("Quarantining infected file {FileName} to {QuarantinePath}", fileName, quarantinePath);
            
            // Reset stream position for quarantine upload
            context.FileStream.Position = 0;
            
            // Upload to quarantine location with metadata about the threat
            var quarantineMetadata = new Dictionary<string, string>
            {
                ["original-filename"] = fileName,
                ["threat-name"] = scanResult.ThreatName ?? "UNKNOWN",
                ["quarantine-timestamp"] = DateTime.UtcNow.ToString("O"),
                ["original-path"] = context.FileMetadata.FileName,
                ["scan-details"] = scanResult.ScanDetails ?? ""
            };
            
            await _storageService.UploadFileAsync(
                "quarantine",
                quarantinePath,
                context.FileStream,
                context.FileMetadata.MimeType,
                cancellationToken);
            
            _logger.LogInformation("File {FileName} successfully quarantined", fileName);
            
            // Mark in context that file was quarantined
            context.SetProperty("QuarantinePath", quarantinePath);
            context.SetProperty("IsQuarantined", true);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to quarantine infected file {FileName}", context.FileMetadata.FileName);
            // Don't throw - we still want to report the malware detection
        }
    }
}